##进入 OTA的方式：
命令格式：{0x82, 9, "OTA_MODE"}

类型：0x82
长度：9
数据："OTA_MODE"

特别说明，这里的那个数据上，指的是ascii码的字符串，最后的结尾部分按照C语言的规定，应该以'\0'结束，所以 整体内容的长度就为 9.

如果不想 写代码翻译，其数据的具体值为：
{0x4F, 0x54, 0x41, 0x5F, 0x4D, 0x4F, 0x44, 0x45, 0x00}


类型		| 数据长度   | 数据内容
:-----  | :-------- | :------
0x82	| 9  | {0x4F, 0x54, 0x41, 0x5F, 0x4D, 0x4F, 0x44, 0x45, 0x00} "OTA_MODE"

执行完该命令后，嵌入式端会擦除现有的app层的代码，并且重新启动自身，然后将自己的设备名字命名为 OTA_MODE 。接下来重新连接设备，按照下面的OTA升级过程中描述的步骤进行OTA操作。

##OTA升级过程
OTA数据包格式

类型：0x81
长度：按照实际需要发送的数据大小设定
数据部分格式：

opcode|数据体的第几块 | 实际的数据内容
:-----  | :-------- | :------
data[0]	| data[1]  | data[2]~data[n]

本数据格式 适用于全部的OTA操作过程，但是data[1]以及后面的data[2]~data[n]只在发送数据实体的时候有效，在OTA_BEGIN和OTA_END的时候是无效的。

###1，手机端发送 OTA_BEGIN命令开始OTA的升级任务。
命令格式：{0x81, 1, 0x00}

类型：0x81
长度：1
数据：0x00

类型		| 数据长度   | 数据内容
:-----  | :-------- | :------
0x81	| 1  | {0x00}

当发送完该命令后，需要等待嵌入式端处理过程。当嵌入式端处理完毕后，嵌入式端会进入等待接收手机端的数据的状态，并且会向手机端发送：
如果发送{0x81, 1, 0x00}表示嵌入式端成功的处理了来自手机端的 OTA_BEGIN命令。之后手机端就可以向嵌入式端发送步骤2中的内容了。
但是如果嵌入式端发送的是{0x81, 1, 0x03}则表示嵌入式在处理OTA_BEGIN的过程中出现错误，这个时候手机端就可以向用户报OTA进入失败的消息。说白了就是 嵌入式擦除flash出现错误。

手机端向嵌入式端发送
{0x81, 1, 0x00} 表示 OTA_BEGIN

手机端接收到的嵌入式端的返回消息| 内容表示的含义
:-----  | :-------- 
{0x81, 1, 0x00}|OTA_BEGIN成功，接下来可以进行步骤2.发送消息实体
{0x81, 1, 0x03}|擦除flash出现错误，OTA_BEGIN失败。可向用户报告flash擦除失败.
{other或者不回应}|可能是嵌入式死机，或者是蓝牙断开，属于特殊情况.

###2.OTA_DATA 手机端 向嵌入式端发送 数据实体。
当发送OTA_BEGIN并且收到 来自嵌入式端的 正确回应后，那么就可以向嵌入式端发送数据实体了。

命令格式：{0x81, 198, data}

类型：0x81
长度：198
数据：data

其中data部分应该按照最开始介绍的OTA的数据包的格式:
data[0]表示的opcode也就是本次要进行的操作，传输数据的opcode是：0x02。data[1]表示的是数据块第几次传输，最开始的时候应该为0，之后每重复一次这里的数字顺序加1。之后的data[2]~data[197]需要从文件中读取。除了最后一次的传输，其他每次传输都需要传196个字节到嵌入式。

发送的次数|手机端发送的内容| 内容表示的含义
:-----  | :-------- | :-----
*1*|{0x81, 198, {data[0] = 0x02, data[1] = 0, data[2], ..., data[197]}}|其中data[2]到以后的数据需要从文件中获取，并且规定，除了最后一个数据块其他都必须按照198的长度传输，并且数据实体为196个。
*2*|{0x81, 198, {data[0] = 0x02, data[1] = 1, data[2], ..., data[197]}}|同上
*3*|{0x81, 198, {data[0] = 0x02, data[1] = 2, data[2], ..., data[197]}}|同上
...|...|...
*n*|{0x81, 198, {data[0] = 0x02, data[1] = n, data[2], ..., data[197]}}|同上
*最后*|{0x81, m, {data[0] = 0x02, data[1] = n+1, data[2], ..., data[m-1]}}|除了长度可以小于198外 其他同上。

手机端需要不断的从文件中读取数据，然后按照上述的特定的格式向嵌入式端发送数据。每发送一次data[1]需要自增一次。

手机端向嵌入式端发送:
{0x81, 198, {data[0] = 0x02, data[1] = 1, data[2], ..., data[197]}

手机端接收到的嵌入式端的返回消息| 内容表示的含义
:-----  | :-------- 
{0x81, 1, 0x02}| 表示成功的接收完手机端传送的数据。并且可以进行下一轮的传输。
{0x81, 1, 0x03}|表示在写flash的时候出现了一定的问题。此时手机可以提示用户flash写入出错
{other或者不回应}|可能是嵌入式死机，或者是蓝牙断开，属于特殊情况。

当不断的传送数据到嵌入式端，并且每次都接收到传入成功的返回直到全部的文件数据全部发送到了嵌入式端。那么接下来手机端就可以向嵌入式端发送步骤3中的命令。

###3.OTA_END 表示全部的数据已经发送完成，嵌入式端开始进行后续的OTA的处理。此时手机的任务就全部完成了。


命令格式：{0x81, 1, 0x01}

类型：0x81
长度：1
数据：0x01

当手机端发送完这个数据后，嵌入式端不会返回任何的内容。

如果成功，嵌入式会开始运行刚才烧录进去的新的 应用程序，如果失败的话，那么嵌入式依旧是 OTA_MODE此时可以开始新一轮的 OTA烧录过程。

